<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Sandbox for canvas-dots canvas demo." />

  <title>GSAP getting started</title>

    <!-- <link rel="stylesheet" type="text/css" href="css/canvas-bubbles-plume.css"> -->
    <!-- Bootstrap Latest compiled and minified CSS -->
    <!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous" -->
    <link rel="apple-touch-icon" href="/bootstrap/img/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/bootstrap/img/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/bootstrap/img/apple-touch-icon-114x114.png">

<!-- jQuery (necessary for plugins) -->
<!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script> -->
<script type="text/javascript" src="js/jquery/src/minified/jquery-3.2.1.min.js"></script>

<!--- The following scripts are necessary to do TweenMax tweens, includes CSSpack properties -->
<script type="text/javascript" src="js/gsap/src/minified/TweenMax.min.js"></script>
<script type="text/javascript" src="js/gsap/src/minified/TimelineMax.min.js"></script>

<script src="./images/effectsData.js"></script>

<!--
One way to explode items at: https://greensock.com/forums/topic/7622-one-way-to-explode-items-example-included/
                        and: https://codepen.io/netgfx/pen/FpiJw?editors=1111

Posted April 28, 2013
This is an example that I tailored that uses GSAP to imitate exploding objects.
It uses multiple canvases on one element but without the need to re-draw them.
I understand this might not be the best solution for large objects but it works
nicely with small objects and it is easy to integrate.
-->

<style type="text/css">
  .people {
    position: absolute;
    top: 6px;
    left: 8px;
  }
  .people a {
      padding: 0 6px;
      text-decoration: underline;
      color: blue;
      cursor: pointer
  }
  .people a:hover {
      color: green;
  }

  .actions {
    position: absolute;
    top: 6px;
    left: 444px;
  }
  .actions a {
      padding: 0 6px;
      text-decoration: underline;
      color: blue;
      cursor: pointer
  }
  .actions a:hover {
      color: green;
  }

  .checkboxes {
    position: absolute;
    top: 6px;
    left: 888px;
  }
  .checkboxes input {
      margin-left: 0px;
      padding: 0 6px;
      text-decoration: underline;
      color: blue;
      cursor: pointer
  }
  .checkboxes input:hover {
      color: green;
  }

  .profileContainer {
    position: absolute;
    top: 40px;
    left: 4px;
    width: 430px;
    height: 438px;
    background-color: blue;
    border: 4px solid green;
  }
  .conversionContainer {
    position: absolute;
    top: 40px;
    left: 446px;
    width: 430px;
    height: 438px;
    background-color: yellow;
    border: 4px solid black;
  }
  .animationContainer {
    position: absolute;
    top: 40px;
    left: 888px;
    width: 430px;
    height: 438px;
    background-color: brown;
    border: 4px solid violet;
  }

</style>
</head>

<body>

  <div class="people">
    <a id="newPhotoMike" style="margin-left: 170px;" photoTag="mike"
       data-src="./images/mike_stern_422x436.jpg"
    >Mike</a>
    <a id="newPhotoMeg" style="margin-left: 10px;" photoTag="meg"
       data-src="./images/meg_CC_422x436.jpg"
    >Meg</a>
  </div>

  <div class="actions">
    <a id="convert" style="margin-left: 0px;">CONVERT</a>
    <a id="explode" style="margin-left: 10px;">EXPLODE!</a>
    <a id="collapse" style="margin-left: 10px;">COLLAPSE!</a>
    <!-- <a id="reset" style="margin-left: 10px;">RESET</a> -->
  </div>

  <div class="checkboxes">
    <input id="checkbox1" type="checkbox">&nbsp;TrrData
  </div>

  <div id="profileContainer" class="profileContainer">
    <img id="selectedPhoto" photoType="color" photoTag="" src="" data-src="" />
  </div>
  <div id="conversionContainer" class="conversionContainer"></div>
  <div id="animationContainer" class="animationContainer"></div>

<script type="text/javascript">

//------------------------------------------------------------------------------
$( document ).ready( function() {
  //----------------------------------------------------------------------------
  console.log( " ..*1) $( document ).ready()");
  // Create plugIn instance, defaults.
  var trrPlugin = new TrrEffect();
  // Select, display default photo.
  trrPlugin.newPhoto( { photoType: "color", photoTag: "meg", imgSrc: './images/meg_CC_422x436.jpg' },
  /*1-Resume here when done*/ function() {
  // Add click handlers for various functions.
  $( "#convert" ).click( function() {
    trrPlugin.convert();
    //trrPlugin.convert( {},
    ///*1-Resume here when done/ function() {
    //var imgSrc = trrPlugin.settings.imgSrc;
    ///*1-/}.bind( trrPlugin ));
  });
  $( "#explode" ).click( function() {
    trrPlugin.explode( { tweenDuration: 3.0 } );
  });
  $( "#collapse" ).click( function() {
    trrPlugin.collapse();
  });
  $( "#reset" ).click( function() {
    trrPlugin.reset();
  });
  $( "#newPhotoMike" ).click( function( event ) {
    trrPlugin.newPhoto( { photoType: "color", photoTag: $(this).attr('photoTag'),
                          imgSrc: $(this).attr('data-src') } );
  });
  $( "#newPhotoMeg" ).click( function( event ) {
    trrPlugin.newPhoto( { photoType: "color", photoTag: $(this).attr('photoTag'),
                          imgSrc: $(this).attr('data-src') } );
  });
  $( "#checkbox1" ).click( function( event ) {
    trrPlugin.useTrrData( { event: event } );
  });
  /*1-*/}.bind( trrPlugin ));
}); //end $( document ).ready()


// plugIn class in context of instance, i.e. this or TrrEffect.xxxx
//------------------------------------------------------------------------------
function TrrEffect() {
  //----------------------------------------------------------------------------
  console.log( " ..*2) TrrEffect() Create new TrrEffect instance. *");
  // Public CONSTANTS accessible via TrrEffect.xxx
  var TAU = Math.PI * 2;
  var ROOT_2 = Math.sqrt( 2 );
  var RGB_CHANNEL_OFFSETS = { red: 0, green: 1, blue: 2 };
  var RGB_CHANNEL_ANGLES = { red: 1, green: 2.5, blue: 5, lum: 4 };
  var timeNow = new Date().getTime();
  var $el = $( '#selectedPhoto' );

  var _this = this;
  this.$el = $el;
  this.defaults = {
    img: document.getElementById( 'selectedPhoto'),
    $img: $el,
    photoTag: $el.attr('photoTag'),
    photoType: $el.attr('photoType'),
    isUseTrrData: false,
    isActionsUseMovedConversionContainer: false,
  };
  $( '#checkbox1' ).prop('checked', this.defaults.isUseTrrData);
  // Create settings for first time, will nit settings from defaults.
  this.settings = updateSettings( { timeNow: timeNow, id: 'mapTrrEffect_' + timeNow } );
	this.particles = [];
  this.conversionContainer = document.getElementById( 'conversionContainer' );
  this.animationContainer = document.getElementById( 'animationContainer' );

  // Public methods accessible via instance. or this.xxxx
  //----------------------------------------------------------------------------
  this.newPhoto = function( options, /*Code to resume when done*/ callback ) {
    //--------------------------------------------------------------------------
    console.log( " ..*3) newPhoto() photoType: '" + options.photoType +
                 "'. photoTag: '" + options.photoTag +
                 "'. Current img.src: '" + this.settings.img.src +
                 "'. New imgSrc: '" + options.imgSrc + "'. *");
    updateSettings( options );
    var src = this.settings.imgSrc,
        img = this.settings.img,
        $img = this.settings.$img;

    img.onload =
    /*1-Resume here when done*/ function() {
    console.log( " ..*3a) newPhoto() img.onload() Loaded src: '" + $img.attr('src') +
                 "'. img.width: '" + img.width + "'. img.height: '" + img.height +
                 "'. *");
    this.getImgData(
    /*2-Resume here when done*/ function() {
    if ( typeof callback == 'function' ) { callback( img ); return; }
    return img;
    /*2-*/}.bind( this ));/*1-*/}.bind( this ); // end img.onload function()

    $img.attr('src', src); // causes photo to be loaded and rendered.
  } // end: this.newPhoto function()

  //----------------------------------------------------------------------------
  this.getImgData = function( /*Code to resume when done*/ callback ) {
    //--------------------------------------------------------------------------
    console.log( " ..*3.1 getImgData() *");

    this.effectsData = { canvasBackgroundColor: '', particles: [] };
    var canvasAndCtx = this.makeCanvasAndCtx();
    var imgCanvas = canvasAndCtx.canvas;
    var ctx = canvasAndCtx.ctx;
    this.imgWidth = imgCanvas.width = this.settings.img.naturalWidth;
    this.imgHeight = imgCanvas.height = this.settings.img.naturalHeight;
    ctx.drawImage( this.settings.img, 0, 0 );
    // ImageData.data Is a Uint8ClampedArray representing a one-dimensional
    // array containing the data in the RGBA order, with integer values between
    // 0 and 255 (included). sarah.jpg imgData.len = '582400'
    this.imgDataObj = ctx.getImageData( 0, 0, this.imgWidth, this.imgHeight );
    this.imgData = this.imgDataObj.data;
    this.imgDataBackgroundRGBA = pixelToRgbxString( this.imgData, 0, true );
    this.imgDataBackgroundRGB = pixelToRgbxString( this.imgData, 0, false );
    console.log( " ..*3.1 getImgData(): imgData.character.len = '" + this.imgData.length +
    						 "'. imgData.RGBA_arrayCells = '" + this.imgData.length / 4 +
    						 "'. imgWidth = '" + this.imgWidth + "'. imgHeight = '" + this.imgHeight +
    						 "'. Image Background RGB() = '" + this.imgDataBackgroundRGB +
                 "'. Image Background RGBA() = '" + this.imgDataBackgroundRGBA + "' *");
    if ( typeof callback == 'function' ) { callback(); return; }
  } // end: this.getImgData function()

  //----------------------------------------------------------------------------
  this.makeCanvasAndCtx = function() {
    //--------------------------------------------------------------------------
  	var canvas = document.createElement('canvas');
  	var ctx = canvas.getContext('2d');
  	return { canvas:canvas, ctx:ctx };
  } // end makeCanvasAndCtx()

  //----------------------------------------------------------------------------
  this.convert = function( options, /*Code to resume when done*/ callback ) {
    //--------------------------------------------------------------------------
    console.log( " ..*4.1) convert() *");

    this.createParticleMap( {
      id: this.settings.id
    },
    /*1-Resume here when done*/ function( particles ) {
    this.particles = particles;
    this.createScene( {
      sceneId: 'scene_Con_' + this.settings.id,
      sceneWidth: 430,
      sceneHeight: 436,
      sceneLeft: 0,
      sceneTop: 0,
      sceneBackgroundColor: '#E7F1F7', // rgb(231, 241, 247) rgba(231, 241, 247, 1)
      //  background color of Climate Corp profile photo for Meg: rgb(234, 233, 238) #eae9ee
      sceneBorder: '',
    },
    /*2-Resume here when done*/ function( scene ) {
    this.scene = scene;
    this.createAnimationElements( {
      animationElementWidth: 6,
      animationElementHeight: 6,
      animationElementColor: '#70C0EF',
      animationElementOffsetX: -80,
      animationElementOffsetY: -20,
    },
    /*3-Resume here when done*/ function() {
    // AnimationElements will display after append()
    this.conversionContainer.appendChild( this.scene );
    /*3-*/}.bind( this ));/*2-*/}.bind( this ));/*1-*/}.bind( this ));
    if ( typeof callback == 'function' ) { callback(); return; }
  } // end: this.convert function()

  //----------------------------------------------------------------------------
  this.explode = function( options, /*Code to resume when done*/ callback ) {
    //--------------------------------------------------------------------------
    this.copyConversionContainerToAnimationContainer( {} ); // { isActionsUseMovedConversionContainer: true }
    var particleContainer = this.animationContainer,
        canvasParticles = $( particleContainer ).find( 'canvas' ),
        canvasParticlesLen = canvasParticles.length;
    console.log( " ..*4.2) explode() particleContainer: '" + particleContainer.id +
                 "' which has " + canvasParticles.length + " canvasParticles" +
                 ". Tween Duration: '" + options.tweenDuration + "'. *");

		for( var i = 0; i < canvasParticlesLen; i++ ) {
			var canvasParticle = canvasParticles.eq(i);
			var randX = getRandom(  300 , -300 );
			var randY = getRandom(  300 , -300 );

			var tmax = TweenMax.to( canvasParticle, options.tweenDuration, {
			  left: randX,
				top: randY,
				autoAlpha: 0,
        ease: Power0.easeInOut
			}); // end TweenMax
		} // end for( var i )
    if ( typeof callback == 'function' ) { callback(); return; }
  } // end: this.explode function()

  //----------------------------------------------------------------------------
  this.copyConversionContainerToAnimationContainer = function( options, /*Code to resume when done*/ callback ) {
    //--------------------------------------------------------------------------
    // local option overrides defaults.
    var isUseConversionScene = options.isActionsUseMovedConversionContainer
      ? options.isActionsUseMovedConversionContainer
      : this.settings.isActionsUseMovedConversionContainer;
    console.log( " ..*4.2.1) copyConversionContainerToAnimationContainer() " +
                 "isUseConversionScene: '" + isUseConversionScene +
                 ( isUseConversionScene ? "'. Copy nothing. animationContainer uses conversionContainer scene"
                                        : "'. Copy' scene in conversionContainer to the animationContainer" ) +
                 "'. *");

    if ( isUseConversionScene ) {
      this.animationContainer.appendChild( this.scene );
      if ( typeof callback == 'function' ) { callback(); return; }
      return;
    }

    // NOTE: Most scene options are used from scene created for the conversionContainer.
    this.createScene( {
      sceneId: 'scene_Ani_' + this.settings.id,
    },
    /*1-Resume here when done*/ function( scene ) {
    this.scene = scene;
    // NOTE: Use same options used for the conversionContainer elements.
    this.createAnimationElements( {},
    /*2-Resume here when done*/ function() {
    // AnimationElements will display after append()
    this.animationContainer.appendChild( this.scene );
    /*2-*/}.bind( this ));/*1-*/}.bind( this ));
    if ( typeof callback == 'function' ) { callback(); return; }
  } // end: this.copyConversionContainerToAnimationContainer function()

  //----------------------------------------------------------------------------
  this.collapse = function( options, /*Code to resume when done*/ callback ) {
    //--------------------------------------------------------------------------
    console.log( " ..*4.3) collapse() *");

    if ( typeof callback == 'function' ) { callback(); return; }
  } // end: this.collapse function()

  /*
  //----------------------------------------------------------------------------
  this.reset = function( options, /*Code to resume when done/ callback ) {
    //--------------------------------------------------------------------------
    console.log( " ..*4.4) reset() plugIn #" + _this.settings.id +
                 ". Empty containerId: " + _this.animationContainer.id +
                 ".<canvas>.len: " + $(_this.animationContainer).find( 'canvas' ).length + ". *");
    $( "#" + _this.settings.id ).empty().remove();
    $(_this.animationContainer).find( 'canvas' ).remove();

    //NOTE: still have <div id='scene_undefined'> in DOM.

    timeNow = new Date().getTime();
    _this.settings = _this.defaults;
    updateSettings( { timeNow: timeNow } );
  	_this.particles = [];
    // Select, display default photo.
    _this.newPhoto( { photoType: "color", photoTag: "meg", imgSrc: './images/meg_CC_422x436.jpg' },
    /*1-Resume here when done* function() {
    if ( typeof callback == 'function' ) { callback(); return; }
  /*1-*}.bind( this ));
  } // end: this.reset function()
  */

  //----------------------------------------------------------------------------
  this.useTrrData = function( options, /*Code to resume when done*/ callback ) {
    //--------------------------------------------------------------------------
    console.log( " ..*4.5) useTrrData() Box checked = '" + $( '#checkbox1' ).prop('checked') + "'. *");
    this.settings.isUseTrrData = $( '#checkbox1' ).prop('checked');
    if ( typeof callback == 'function' ) { callback(); return; }
  } // end: this.useTrrData function()

  //----------------------------------------------------------------------------
  this.createParticleMap = function( options, /*Code to resume when done*/ callback ) {
    //--------------------------------------------------------------------------
    console.log( " ..*5) createParticleMap() for id: '" + options.id +
                 "'. useTrrData: '" + this.settings.isUseTrrData + "'. *");
    var particles = [];
    if ( this.settings.isUseTrrData ) {
      particles = this.makeParticlesFromTrrMap( {
        id: options.id,
        effectsDataAsJSONstring: effectsDataForRender[0].effectsDataAsJSONstring,
        particlesHomeOffsetLeft: 80,
        particlesHomeOffsetTop: 20,
      } );
    } else {
      particles = this.makeCartesianGridParticles( {
        id: options.id,
        particlesHomeOffsetLeft: 82,
        particlesHomeOffsetTop: 20,
      } );
    }
    console.log( " ..*5a) createParticleMap() Created particles[" + particles.length + "] *");
    if ( typeof callback == 'function' ) { callback( particles ); return; }
    return particles;
  } // end: this.createParticleMap function()

  //----------------------------------------------------------------------------
  this.makeParticlesFromTrrMap = function( options, /*Code to resume when done*/ callback ) {
    //--------------------------------------------------------------------------
    updateSettings( options );
    var effectsData = JSON.parse( this.settings.effectsDataAsJSONstring );
    console.log( " ..*5.1) makeParticlesFromTrrMap() for id: " + this.settings.id +
                 ". effectsData.particles.len = " + effectsData.particles.length +
                 ". effectsDataAsJSONstring.len = " + this.settings.effectsDataAsJSONstring.length +
                 ". Canvas Particles Home position Offset left: " + this.settings.particlesHomeOffsetLeft +
                 ". top: " + this.settings.particlesHomeOffsetTop + ".");

    var particles = new Array();
    var effectsDataParticles = effectsData.particles,
        edpParticle = {},
        homeOffsetLeft = this.settings.particlesHomeOffsetLeft,
        homeOffsetTop = this.settings.particlesHomeOffsetTop;

    for( var i = 0; i < (effectsData.particles.length); i += 1 ) {
        edpParticle = effectsDataParticles[ i ];
        particles.push( {
            x: edpParticle.x + homeOffsetLeft,
            y: edpParticle.y + homeOffsetTop,
            r: edpParticle.r,
        });
    } //end for( var n )

    if ( typeof callback == 'function' ) { callback( particles ); return; }
    return particles;
  } // end: this.makeParticlesFromTrrMap function()

  //----------------------------------------------------------------------------
  this.makeCartesianGridParticles = function( options, /*Code to resume when done*/ callback ) {
    //--------------------------------------------------------------------------
    updateSettings( options );
    console.log( " ..*5.2) makeCartesianGridParticles() for id: " + this.settings.id +
                 ". Particles Home position Offset left: " + this.settings.particlesHomeOffsetLeft +
                 ". top: " + this.settings.particlesHomeOffsetTop + ".");

    this.settings.rgbChannel = 'blue'; // this.settings.halftoneColor
    this.settings.rgbChannelOffset = RGB_CHANNEL_OFFSETS[ this.settings.rgbChannel ];
    this.settings.maxHalftoneDotSize = 1/150;
    this.settings.pixelChannelIntensityThreshold = 0.05;
    this.settings.imageScale = 1.0; // canvas.width / imgWidth;
    this.settings.rgbChannelAngle = RGB_CHANNEL_ANGLES[ this.settings.rgbChannel ];
    this.conversionContainerBackgroundRGB = this.imgDataBackgroundRGB;
    this.conversionContainerBackgroundRGBA = this.imgDataBackgroundRGBA;

    this.particlesRejectedBecauseParticleIsOutOfBounds = 0;
    this.particlesRejectedBecausePixelIntensityLessThanThreshold = 0;
    this.particlesRejectedBecausePixelSameAsConversionContainerBackgroundRGB = 0;
    this.particlesRejectedBecausePixelSameAsConversionContainerBackgroundRGBA = 0;

    var particles = [],
        homeOffsetLeft = this.settings.particlesHomeOffsetLeft,
        homeOffsetTop = this.settings.particlesHomeOffsetTop,
        image_width = this.settings.img.width,
        image_heigth = this.settings.img.height,
        diagonal = Math.sqrt( (image_width * image_width) + (image_heigth * image_heigth) ),
        gridSize = this.settings.maxHalftoneDotSize * diagonal,
        angle = this.settings.rgbChannelAngle,
        diag = Math.max( image_width, image_heigth ) * ROOT_2,
        cols = Math.ceil( diag / gridSize ),
        rows = Math.ceil( diag / gridSize ),
        maxNumOfParticles =  rows * cols;

    console.log( " ..*5.2a) makeCartesianGridParticles(): BEGIN LOOP: " +
                 ". gridSize = " + gridSize + ". rows = " + rows +
                 ". columns = " + cols + ". Max number of particles = " +
                 maxNumOfParticles + ". *");

    var isTerminateLoop = false;
    for ( var row = 0; row < rows; row++ ) {
      if ( isTerminateLoop) {
        break;
      }
      for ( var col = 0; col < cols; col++ ) {
        var x1 = 0, home_position_x = 0, y1 = 0, home_position_y = 0;
        x1 = ( col + 0.5 ) * gridSize;
        y1 = ( row + 0.5 ) * gridSize;
        x1 -= ( diag - image_width ) / 2;
        y1 -= ( diag - image_heigth ) / 2;
        x1 -= image_width / 2;
        y1 -= image_heigth / 2;
        home_position_x = x1 * Math.cos(angle) - y1 * Math.sin(angle);
        home_position_y = x1 * Math.sin(angle) + y1 * Math.cos(angle);
        home_position_x += image_width / 2;
        home_position_y += image_heigth / 2;

        // Returns null if rejected. Else returns Particle.
        // NOTE: rejected particle locations just stay whatever the canvas
        // background/fill color is.
        var filterResults = this.particleFilter( this.settings.rgbChannel, home_position_x, home_position_y );
        if ( filterResults.isAccepted ) {
          particles.push( {
            // NOTE: x2, y2 is the 'home' location on the image.
            x: filterResults.x + homeOffsetLeft,
            y: filterResults.y+ homeOffsetTop,
            //rgbaValue: particle.rgbaValue,
            //dotRadius: particle.naturalSize,
            r: filterResults.pixelChannelIntensity * gridSize,
          });
        }
      } // end for (col)
    } // end for (row)
    console.log( " ..*5.2b) makeCartesianGridParticles(): END LOOP: particles[].len = " +
                 particles.length + ". Out of " + maxNumOfParticles + " possible. " +
                 "Particles Rejected Because Particle Is Out Of Bounds = '" +
                 this.particlesRejectedBecauseParticleIsOutOfBounds +
                 "'. Particles Rejected Because Pixel Intensity Less Than Threshold = '" +
                 this.particlesRejectedBecausePixelIntensityLessThanThreshold +
                 "'. Particles Rejected Because Pixel Same As Conversion Container Background RGBA = '" +
                 this.particlesRejectedBecausePixelSameAsConversionContainerBackgroundRGBA +
                 "'. Particles Rejected Because Pixel Same As Conversion Container Background RGB = '" +
                 this.particlesRejectedBecausePixelSameAsConversionContainerBackgroundRGB +
                 "'. *");
    if ( typeof callback == 'function' ) { callback( particles ); return; }
     return particles;
  } // end: this.makeParticles function()

  //----------------------------------------------------------------------------
  this.particleFilter = function( rgbChannel, x, y ) {
    //----------------------------------------------------------------------------
    if (this.settings.imageScale !== 1.0 ) {
        x = Math.round( x / this.settings.imageScale);
        y = Math.round( y / this.settings.imageScale);
    } else {
      x = Math.round( x );
      y = Math.round( y );
    }

    if ( x < 0 || x > this.settings.img.width ||
         y < 0 || y > this.settings.img.height ) {
      this.particlesRejectedBecauseParticleIsOutOfBounds += 1;
      return { isAccepted: false };
    }

    var pixelInfo = this.getPixelInfo( x, y, rgbChannel );

    if ( pixelInfo.channelIntensity < this.settings.pixelChannelIntensityThreshold ) {
      this.particlesRejectedBecausePixelIntensityLessThanThreshold += 1;
      return { isAccepted: false };
    }

    if ( pixelInfo.rgbString == this.conversionContainerBackgroundRGB ) {
      pixelInfo.rgbaString == this.conversionContainerBackgroundRGBA
        ? this.particlesRejectedBecausePixelSameAsConversionContainerBackgroundRGBA += 1
        : this.particlesRejectedBecausePixelSameAsConversionContainerBackgroundRGB += 1;
      return { isAccepted: false };
    }

    return {
      isAccepted: true,
      x: x,
      y: y,
      pixelChannelIntensity: pixelInfo.channelIntensity,
    };
  } // end this.particleFilter()

  //----------------------------------------------------------------------------
  this.getPixelInfo = function( x, y, rgbChannel ) {
    //--------------------------------------------------------------------------
    // this.imgData Is a Uint8ClampedArray representing a one-dimensional
    // array containing the data in the RGBA order, with integer values between
    // 0 and 255 (included). sarah.jpg imgData.len = '582400'
    var pixelIndex = ( x + y * this.settings.img.width ) * 4;
    var pixelChannelValue = rgbChannel === 'lum'
          ? this.getPixelLum( pixelIndex )
          : this.imgData[ pixelIndex + this.settings.rgbChannelOffset ]; // get the 'blue' value of the rgba item.
    pixelChannelValue =  1 - (pixelChannelValue / 255);
    return {
      channelIntensity: pixelChannelValue,
      rgbaString: pixelToRgbxString( this.imgData, pixelIndex, true ),
      rgbString: pixelToRgbxString( this.imgData, pixelIndex, false ),
    };
  } // end getPixelChannelIntensity()

  //----------------------------------------------------------------------------
  this.getPixelLum = function( pixelIndex ) {
    //----------------------------------------------------------------------------
    var r = this.imgData[ pixelIndex + 0 ] / 255;
    var g = this.imgData[ pixelIndex + 1 ] / 255;
    var b = this.imgData[ pixelIndex + 2 ] / 255;
    var max = Math.max( r, g, b );
    var min = Math.min( r, g, b );
    return ( max + min ) / 2;
  } // end getPixelLum()


  // ( imgObj, left, top, id )
  //----------------------------------------------------------------------------
  this.createScene = function( options, /*Code to resume when done*/ callback ) {
    //--------------------------------------------------------------------------
    updateSettings( options );
    console.log( " ..*6) createScene() *");

    var container = document.createElement( "div" );
    container.id = this.settings.sceneId;
    container.style.width = this.settings.sceneWidth + "px";
    container.style.height = this.settings.sceneHeight + "px";
    container.style.position = "absolute";
    container.style.left = this.settings.sceneLeft + "px";
    container.style.top  = this.settings.sceneTop + "px";
    container.style.backgroundColor  = this.settings.sceneBackgroundColor;
    container.style.border  = this.settings.sceneBorder;

    console.log( " ..*6a) createScene() container.width: " +  container.style.width +
                 ". container.height: " + container.style.height +
                 ". Container Offset left: " + container.style.left + ". top: " + container.style.top + "'*");

    if ( typeof callback == 'function' ) { callback( container ); return; }
    return container;
  } // end: this.createScene function()

  //----------------------------------------------------------------------------
  this.createAnimationElements = function( options, /*Code to resume when done*/ callback ) {
    //--------------------------------------------------------------------------
    updateSettings( options );
    var scene = this.scene,
        canvas = null,
        context = null
        particles = this.particles,
        particlesLen = particles.length,
        canvasWidth = this.settings.animationElementWidth,
        canvasHeight = this.settings.animationElementHeight,
        dotsColor = this.settings.animationElementColor,
        canvasOffsetX = this.settings.animationElementOffsetX,
        canvasOffsetY = this.settings.animationElementOffsetY;
    console.log( " ..*7) createAnimationElements() for " + particles.length + " particles. " +
                 " Each canvasElement has width: '" + canvasWidth +
                 "'. height: '" + canvasHeight + "'. dotsColor: '" + dotsColor + "'. *");

    for( var n = 0; n < particles.length; n++ ) {
      var particle = particles[ n ];

      canvas = document.createElement( "canvas" );
      context = canvas.getContext("2d");

      canvas.width = canvasWidth;
    	canvas.height = canvasHeight;
    	canvas.style.left = particle.x + canvasOffsetX + "px";
    	canvas.style.top = particle.y + canvasOffsetY + "px";
  		canvas.style.position = 'absolute';

      // NOTE: Callbacks available? else it seems browsers is busy making
      // canvas elems and we exit for loop.
      context.fillStyle = dotsColor;
      context.beginPath();
      context.arc( 0, 0, particle.r, 0, TAU );
      context.fill();
      context.closePath();

      scene.appendChild( canvas );
    } // end for( var n)
    console.log( " ..*7a) createAnimationElements() DONE for " + particles.length + " particles. " +
                 " Created " + $(scene).find( 'canvas' ).length + " canvasParticles. *");

    if ( typeof callback == 'function' ) { callback( scene ); return; }
    return scene;
  } // end: this.createAnimationElements function()

  /*
  this.fadeIn( {},
  /*4-Resume here when done/ function() {
  /*4-/}.bind( this ));
  //----------------------------------------------------------------------------
  this.fadeIn = function( options, /*Code to resume when done/ callback ) {
    //--------------------------------------------------------------------------
    console.log( " ..*8) fadeIn() *");
    this.animationContainer.appendChild( this.scene );
    if ( typeof callback == 'function' ) { callback(); return; }
  } // end: this.fadeIn function()
  */

  // Private methods in context of plugIn instance, i.e. this
  // // NOTE: Private methods MUST use _this to get 'this' for this instance.
  //----------------------------------------------------------------------------
  function updateSettings( options ) {
    //--------------------------------------------------------------------------
    if ( options == 'undefined') {
      return _this.settings;
    }
    return _this.settings = $.extend( {}, _this.settings || _this.defaults, options );
  }
}; // end function TrrEffect()

// Static methods in context of window
//------------------------------------------------------------------------------
function getRandom( max, min ) {
  //----------------------------------------------------------------------------
  return Math.floor( Math.random() * ( 1 + max - min ) + min );
} // end function getRandom()

//------------------------------------------------------------------------------
function pixelToRgbxString( pixelArray, pixelIndex, isIncludeA ) {
  //----------------------------------------------------------------------------
  return "rgb"   + (isIncludeA ? "a" : "") +
         "( "    + pixelArray[ pixelIndex + 0 ] +
            ", " + pixelArray[ pixelIndex + 1 ] +
            ", " + pixelArray[ pixelIndex + 2 ] +
            (isIncludeA ?
            ", " + pixelArray[ pixelIndex + 3 ] : "") +
         " )";
} // end pixelToRgbxString()

</script>

</body>

</html>

<!-- PREVIOUS EXAMPLES ========================= -->

<!--

<body>

<center style="margin-top: 80px;">
<img id="photo" src="https://mdn.mozillademos.org/files/5397/rhino.jpg">
</center>

<script type="text/javascript">

  var element = $("#photo");

  // Sequencing and grouping tweens with TimelineLite

  // Unlike most other JS animation tools, sequencing in GSAP is much more
  // flexible than building a queue of tweens that run one-after-the-other.
  // You have complete control over the relative timing of each tween - they
  // can overlap as much as you want. And you can control entire sequences as
  // a whole, reverse smoothly anytime, jump to any point, adjust the timeScale,
  // etc. and everything renders in the proper order. Watch this video for a
  // visual demo showing how TimelineLite can save you a lot of time. Of course
  // you could sequence tweens by using the "delay" special property on all your
  // tweens, but that can get complicated when you build a long sequence and
  // then later want to change the timing of something early in the sequence
  // (you'd have to adjust all the delay values in tweens after that). Plus it
  // would be a pain to control the whole sequence, like to pause() or resume()
  // or reverse() the group on-the-fly. Sequencing is much easier with
  // TimelineLite and its big brother, TimelineMax.

  // Let's jump into some sample code:

  //create a TimelineLite instance
  var tl = new TimelineMax();

  //append a to() tween
  tl.to(element, 1, { width: "50%" });

  //add another sequenced tween (by default, tweens are added to the end of the
  //timeline which makes sequencing simple)
  tl.to(element, 1, { height: "300px", ease:Elastic.easeOut });

  //offset the next tween by 0.75 seconds so there's a gap between the end of the previous tween and this new one
  tl.to(element, 1, {opacity:0.5}, "+=0.75");

  t1.to(element, 2, {rotation:"-170_short"}, "+=0.75");

  //overlap the next tween with the previous one by 0.5 seconds (notice the negative offset at the end)
  tl.to(element, 1, {backgroundColor:"#FF0000"}, "-=0.5");

  //animate 3 elements (e1, e2, and e3) to a rotation of 60 degrees, and stagger their start times by 0.2 seconds
  //tl.staggerTo([e1, e2, e3], 1, {rotation:60}, 0.2);

  //then call myFunction()
  tl.call(myFunction);

    //reverse (always goes back towards the beginning)
  //  setTimeout( function() {
  //    tween.reverse();
  //  }, 7000);

  //now we can control the entire sequence with the standard methods like these:
  //tl.pause();
  //tl.resume();
  //tl.restart();
  //tl.reverse();
  //tl.play();

  //jump to exactly 2.5 seconds into the animation
  //tl.seek(2.5);

  //slow down playback to 10% of the normal speed
  //tl.timeScale(0.1);

  //add a label named "myLabel" at exactly 3 seconds:
  //tl.add("myLabel", 3);

  //add a tween that starts at "myLabel"
  //tl.add( TweenLite.to(element, 1, {scale:0.5}), "myLabel");

  //jump to "myLabel" and play from there:
  //tl.play("myLabel");

  // Think of a timeline (as in a TimelineLite or TimelineMax instance) like a
  // collection of tweens that are positioned at specific places on that
  // timeline. It controls their playback. Timelines can be nested inside other
  // timelines as deeply as you want. This is a very powerful concept because
  // it allows you to control entire sequences in a modular way. Imagine 100
  // characters individually animating into place in a staggered fashion
  // (100 tweens). They could all be grouped into a TimelineLite instance and
  // then controlled as a whole (using common methods like pause(), resume(),
  // reverse(), restart(), etc.). In fact, you could create functions that
  // return animations wrapped in a TimelineLite so that you can easily build
  // a larger, more complex animation in a modular way. A central concept to
  // grasp is that every tween is inserted into a timeline. By default, it's
  // the root timeline inside the engine. When a timeline is playing, its
  // virtual playhead advances. If you reverse() a timeline, the playhead
  // travels in the opposite direction back towards its beginning. As the
  // timeline's playhead encounters tweens, it plays them accordingly.
  // For example, if the playhead is positioned halfway through a tween, that
  // tween will render as though it is 50% finished. If the timeline's
  // timeScale is set to 0.5, that would cause the playhead to travel at half
  // speed. Consequently, any tweens it encounters would also appear to progress
  // at half speed. Once you get the hang of how timelines work, they can
  // revolutionize your animation workflow. Just like tweens, timelines play
  // immediately by default but you can pause them initially using pause() or
  // by setting paused:true in the vars parameter of the constructor. There are
  // quite a few methods available in the timeline classes that give you precise
  // control, and we'd encourage you to look through the TimelineLite
  // Documentation to see what's available. If you can think of something you'd
  // like to do, chances are there's a way to do it.

</script>

</body>
-->

<!--
<body>

<center style="margin-top: 200px;">
<img id="photo" src="https://mdn.mozillademos.org/files/5397/rhino.jpg">
</center>

<script type="text/javascript">

  var element = $("#photo");

  // Controlling tweens

  // Most other animation tools offer very limited controls, but GSAP was built
  // from the ground up to be a professional-grade robust set of animation
  // tools. You can easily pause(), resume() reverse(), restart(), seek(), or
  // even alter the timeScale of any tween. In fact, you can tween the timeScale
  // of another tween to gradually slow it down or speed it up. To control a
  // tween, however, you need an instance to work with. The to(), from(), and
  // fromTo() methods all return an instance, so you can dump it into a variable
  // as easily as:

  //using the static to() method...
  //var tween = TweenLite.to(element, 1, {width:"50%"});

  //or use the object-oriented syntax...
  var tween = new TweenLite(element, 5, {width:"50%"});

  // Then, you can call any of its methods:

  //pause
  //tween.pause();

  //resume (honors direction - reversed or not)
  //tween.resume();

  //reverse (always goes back towards the beginning)
  setTimeout( function() {
    tween.reverse();
  }, 7000);

  //jump to exactly 0.5 seconds into the tween
  //tween.seek(0.5);

  //make the tween go half-speed
  //tween.timeScale(0.5);

  //make the tween go double-speed
  //tween.timeScale(2);

  //immediately kill the tween and make it eligible for garbage collection
  //tween.kill();

  // You can also kill ALL of the tweens of a particular element/target like this:

  // TweenLite.killTweensOf(myElement);

  // See the TweenLite Documentation for details about all of the properties
  // and methods available.

</script>

</body>
-->

<!--
<body>

<center style="margin-top: 200px;">
<img id="photo" src="https://mdn.mozillademos.org/files/5397/rhino.jpg">
</center>

<script type="text/javascript">

  var element = $("#photo");

  // directionalRotation -

  // tweens rotation in a particular direction which can
  // be either clockwise ("_cw" suffix), counter-clockwise ("_ccw" suffix), or
  // in the shortest direction ("_short" suffix) in which case the plugin
  // chooses the direction for you based on the shortest path. For example,
  // if the element's rotation is currently 170 degrees and you want to tween
  // it to -170 degrees, a normal rotation tween would travel a total of 340
  // degrees in the counter-clockwise direction, but if you use the "_short"
  // suffix, it would travel 20 degrees in the clockwise direction instead.
  // Example
  //TweenLite.to(element, 2, {rotation:"-170_short"});

  // or even use it on 3D rotations and use relative prefixes:
  //TweenLite.to(element, 2, {rotation:"-170_short", rotationX:"-=30_cw", rotationY:"1.5rad_ccw"});

  // Prior to version 1.9.0, directionalRotation was called shortRotation and it
  // only handled going in the shortest direction. The new directionalRotation
  // functionality is much more flexible and easy to use (just slap a suffix on
  // the regular property). For backwards compatibility, CSSPlugin still
  // recognizes "shortRotation", but it has been deprecated.

  // autoAlpha - the same thing as "opacity" except that when the value hits "0",
  // the "visibility" property will be set to "hidden" in order to improve
  // browser rendering performance and prevent clicks/interactivity on the
  // target. When the value is anything other than 0, "visibility" will be set
  // to "visible".
  // Example: fade out and set visibility:hidden
  //TweenLite.to(element, 5, {autoAlpha:0});
  // in 2 seconds, fade back in with visibility:visible
  //TweenLite.to(element, 10, {autoAlpha:1, delay:7});

  // className -
  // allows you to morph between classes on an element. For example, let's say
  // myElement has a class of "class1" currently and you want to change to
  // "class2" and animate the differences, you could do this:
  //TweenLite.to(myElement, 1, {className:"class2"});

  // And if you want to ADD the class to the existing one, you can simply use
  // the "+=" prefix. To remove a class, use the "-=" prefix like this:
  //TweenLite.to(myElement, 1, {className:"+=class2"});

  // Note: there are a few css-related properties that don't tween like IE
  // filters, but that is a very rare exception. Also, there is a slight speed
  // penalty when using className because the engine needs to loop through all
  // of the css properties to analyze which ones are different.

  // autoRound -
  // By default, CSSPlugin will round pixel values and zIndex to the closest
  // integer during the tween (the inbetween values) because it improves browser
  // performance, but if you'd rather disable that behavior, pass
  // autoRound:false in the css object. You can still use the RoundPropsPlugin
  // to manually define properties that you want rounded.

</script>

</body>
-->

<!--

<body>

<center style="margin-top: 200px;">
<img id="photo" src="https://mdn.mozillademos.org/files/5397/rhino.jpg">
</center>

<script type="text/javascript">

  var photo = $("#photo");
  // transformOrigin - Sets the origin around which all transforms occur.
  // By default, it is in the center of the element ("50% 50%"). You can
  // define the values using the keywords "top", "left", "right", or "bottom"
  // or you can use percentages (bottom right corner would be "100% 100%") or
  // pixels. If, for example, you want an object to spin around its top left
  // corner you can do this:

  // spins around the element's top left corner
  TweenLite.to("#photo", 2, {rotation:360, transformOrigin:"left top"});


</script>

</body>
-->

<!--
  var photo = $("#photo");
  // You can animate 3D transform properties and 2D properties (except skew)
  // together intuitively:
  TweenLite.to("#photo", 2, {rotationX:720, scaleX:1.8, z:-100});
-->

<!--
  var photo = $("#photo");
  // By default, rotation, skewX, and skewY use degrees but you can use radians
  // if you prefer. Simply append one of the standard suffixes ("rad" or "deg")
  // like this:
  //use "deg" or "rad"
  TweenLite.to(photo, 2, {rotation: "300deg", skewX:"30deg"});
-->

<!--
  var photo = $("#photo");

  //Plugins
  // Think of plugins like special properties that are dynamically added to
  // TweenLite, giving it extra abilities. This keeps the core engine small and
  // efficient, yet allows for virtually unlimited capabilities to be added
  // dynamically. Each plugin is associated with a property name and it takes
  // responsibility for handling that property. For example, the CSSPlugin is
  // associated with the "css" property name so if it loaded, it will intercept
  // the "css" property, and the ScrollToPlugin will intercept the "scrollTo"
  // value, etc.:

  //CSSPlugin will intercept the "css" value...
  TweenLite.to(photo, 1, {css:{scaleX:0.5, rotation:30}, ease:Power3.easeOut});

  //ScrollToPlugin will intercept the "scrollTo" value (if it's loaded)...
  TweenLite.to(window, 2, {scrollTo:{y:300}, ease:Bounce.easeOut});
-->

<!--
  var photo = $("#photo");

// To get linear motion, just use the Linear.easeNone ease.
TweenLite.to(photo, 1, {width:100, ease:"Linear.easeNone"});
TweenLite.to(photo, 1, {height:200, ease:"Linear.easeNone"});
-->

<!--

  var photo = $("#photo");

  // The default ease in TweenLite is Power1.easeOut (which gives a more natural
  // feel than a linear ease). Here is the syntax for defining the ease for a
  // few tweens:
  TweenLite.to(photo, 1, {width:100, ease:Power2.easeOut});
  TweenLite.to(photo, 1, {height:200, ease:Elastic.easeOut});
-->

<!--
Let's say, for example, you have an <img> with an id of "photo" and you'd like
to tween its "width" property to a value of 100 over the course of 1.5 seconds.
You can use TweenLite's to() method:

<style type="text/css">

</style>
</head>

<body>

<img id="photo" src="https://mdn.mozillademos.org/files/5397/rhino.jpg">

<script type="text/javascript">

  var photo = $("#photo");

  //notice there's no "()" after the onComplete function because it's just a reference to the function itself (you don't want to call it yet)
  TweenLite.to(photo, 1.5, {width:100, delay:0.5, onComplete:myFunction});
  function myFunction() {
      console.log("tween finished");
  }

</script>

</body>
-->

<!--
The logo element will now have its css "left" property tweened to 632px over the course of 1 second. The syntax is:
TweenLite.to( [target object], [duration in seconds], [destination values] )
-->
<!--
<style type="text/css">
    body{
      background-color:#000;
      color:white;
    }
    #demo {
      width: 692px;
      height: 60px;
      background-color: #333;
      padding: 8px;
    }
    #logo {
      position: relative;
      width: 60px;
      height: 60px;
      background: url(https://s3-us-west-2.amazonaws.com/s.cdpn.io/16327/logo_black_1.jpg)no-repeat;
    }
</style>
</head>

<body>

<div id="demo">
    <div id="logo"></div>
</div>


<script type="text/javascript">
//we'll use a window.onload for simplicity, but typically it is best to use either jQuery's $(document).ready() or $(window).load() or cross-browser event listeners so that you're not limited to one.
window.onload = function(){
    var logo = document.getElementById("logo");
    TweenLite.to(logo, 1, {left:"632px"});
}
</script>

</body>
-->
